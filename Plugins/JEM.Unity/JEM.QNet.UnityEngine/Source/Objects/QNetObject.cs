//
// QNet For Unity Source
//
// Copyright (c) 2019 ADAM MAJCHEREK ALL RIGHTS RESERVED
//

#define DEEP_DEBUG

using JEM.Core.Common;
using JEM.QNet.Messages;
using JEM.QNet.UnityEngine.Messages;
using JEM.QNet.UnityEngine.Simulation;
using JetBrains.Annotations;
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using UnityEngine.Profiling;

namespace JEM.QNet.UnityEngine.Objects
{
    /// <summary>
    ///     Enum used to define a type of OBJECT_QUERY.
    /// </summary>
    internal enum QNetObjectComponentQuery : byte
    {
        Unknown,

        /// <summary>
        ///     Add component of given type.
        /// </summary>
        AddComponent,

        /// <summary>
        ///     Destroy component of given type and index.
        /// </summary>
        DestroyComponent
    }

    /// <inheritdoc />
    /// <summary>
    ///     QNet Object.
    ///     Base of every object that implements and utilizes networking.
    /// </summary>
    public abstract partial class QNetObject : QNetSimulableObject
    {
        /// <summary>
        ///     Reference to the QNetIdentity component.
        /// </summary>
        public QNetIdentity Identity { get; private set; }

        /// <summary>
        ///     A index of this component generated by QNetIdentity.
        /// </summary>
        public byte ComponentIndex { get; internal set; }

        /// <summary>
        ///     True if this is a custom component.
        ///     A custom component is a component that has been added runtime and can be removed.
        /// </summary>
        public bool IsCustomComponent { get; private set; }

        /// <summary>
        ///     A reference to a prefab this QNet entity was spawned from.
        /// </summary>
        public QNetIdentity Prefab { get; private set; }

        /// <summary>
        ///     A identity of prefab of this object so the it cloud be replicated on other clients.
        /// </summary>
        public ushort PrefabIdentity { get; private set; }

        /// <summary>
        ///     True if local client is a owner of this QNetObject.
        ///     NOTE: Server will always have this property set to false. Use IsServerObject instead.
        /// </summary>
        public bool IsOwner { get; private set; }

        /// <summary>
        ///     True if this object has been spawned with no owner.
        /// </summary>
        public bool IsServerObject { get; private set; }

        /// <summary>
        ///     Defines if this object has the server state de-serialized.
        /// </summary>
        /// <remarks>
        ///     Server will always have this set to true.
        /// </remarks>
        public bool HasStateDeserialized { get; private set; }

        /// <summary>
        ///     True, if this object has been initialized.
        /// </summary>
        internal bool IsInitialized { get; private set; }

        /// <summary>
        ///     True, if this object is currently being destroyed by network scene.
        /// </summary>
        public bool IsDestroying { get; private set; }

        protected virtual void Awake()
        {
            Identity = GetComponent<QNetIdentity>();
            if (Identity == null)
            {
                enabled = false;
                QNetManager.PrintLogError("QNetObject based component has been activated on gameObject that does not have QNetIdentity on it.", this);
                return;
            }

            // Initialize this object with local identity.
            Identity.InitializeObject(this);

            // Check if the identity is initialized.
            if (Identity.IsInitialized && QNetNetworkScene.SceneState == QNetSceneState.Loaded)
            {
                // The identity is already initialized so we need to init this component and spawn it from here.
                if (ClientIsModifyingCustomComponent)
                {
                    return;
                }

                if (!IsServer)
                {
                    enabled = false;
                    throw new NotSupportedException("Adding new QNetObject based component " +
                                                    "can only be done from the server!");
                }

                if (!GetQNetObjectIndex(GetType(), out var typeIndex))
                {
                    enabled = false;
                    throw new NullReferenceException("Failed to initialize new component. " +
                                                     $"Unable to find typeIndex for type {GetType().FullName}.");
                }

#if DEBUG && DEEP_DEBUG
                QNetManager.PrintLogMsc($"QNetObject.Awake() add_component_type: {typeIndex}", this);
#endif

                // Create outgoing message
                var outgoingMessage = QNetManager.GenerateServerMessage(QNetUnityHeader.OBJECT_QUERY);

                // Write header
                outgoingMessage.WriteUInt16(Identity);
                outgoingMessage.WriteEnum(QNetObjectComponentQuery.AddComponent);
                outgoingMessage.WriteByte(ComponentIndex);
                outgoingMessage.WriteByte(typeIndex);

                // Initialize custom component.
                InitializeCustomComponent(ComponentIndex, typeIndex, Identity.IsSpawned);

                // Serialize component
                CallOnSerializeServerState(outgoingMessage);

                // Send component to other clients.
                QNetManager.SendToAll(QNetBaseChannel.DEFAULT, QNetMessageMethod.ReliableOrdered, outgoingMessage);
            }
        }

        /// <inheritdoc />
        protected override void OnDestroy()
        {
            // Invoke base method.
            base.OnDestroy();

            // Check if object is really being destroyed.
            if (IsInitialized && !IsDestroying && !QNetManager.Instance.ShuttingDownByApplicationQuit && IsCustomComponent && 
                QNetNetworkScene.SceneState == QNetSceneState.Loaded)
            {
                // Only this component is being destroyed.
                if (Identity == this)
                    throw new NotSupportedException("You can't destroy QNetIdentity object.");

                if (ClientIsModifyingCustomComponent)
                {
                    return;
                }

                if (!IsServer)
                {
                    enabled = false;
                    throw new NotSupportedException("Removing QNetObject based component " +
                                                    "can only be done from the server!");
                }

#if DEBUG && DEEP_DEBUG
                QNetManager.PrintLogMsc($"QNetObject.OnDestroy component_index: {ComponentIndex}", this);
#endif

                // Send component destroy to other clients.
                QNetManager.SendToAll(QNetBaseChannel.DEFAULT, QNetMessageMethod.ReliableOrdered, QNetUnityHeader.OBJECT_QUERY, (ushort) Identity,
                    QNetObjectComponentQuery.DestroyComponent, ComponentIndex);

                // Destroy!
                DestroyCustomComponent(false);
            }
        }

        /// <summary>
        ///     Initialize this QNetObject.
        /// </summary>
        internal void Initialize(QNetIdentity prefab, ushort prefabIdentity, ushort identity, QNetConnection ownerConnection, ushort owner)
        {
            if (IsInitialized)
            {
                return;
            }

            if (identity == 0)
                throw new NotSupportedException("You are trying to initialize QNetObject based component with invalid identity (zero)!");

            Profiler.BeginSample("QNetObject.Initialize");

            // Set prefab.
            Prefab = prefab;
            PrefabIdentity = prefabIdentity;

            // Collect components.
            //Identity = GetComponent<QNetIdentity>();

            // Check.
            QNetManager.PrintLogAssert(Identity, "QNetIdentity component not found " +
                                                 "on object of QNetObject based lass.", this);

            Profiler.BeginSample("QNetObject.Initialize loads methods");

            // Load methods.
            LoadMethods();

            Profiler.EndSample();

            // call onInitialize.
            _onInitialize.Invoke();

            // Update initialization state.
            // NOTE: State need to be changed before Identity.LoadIdentity
            //        that is initializing all QNetObject added to this gameObject (guaranteed overflow).
            IsInitialized = true;

            // Update de-serialization state.
            HasStateDeserialized = IsServer;

            // Initialize identity.
            var hasConnection = !ownerConnection.Equals(default(QNetConnection)) || owner != 0;
            Identity.LoadIdentity(identity, ownerConnection, owner, hasConnection);

            // Update server owner state
            IsServerObject = !Identity.HasOwner;
            // Update local owner state
            IsOwner = QNetManager.Instance.Client != null && Identity.IsOwner(QNetManager.Instance.Client.ConnectionIdentity);

#if DEBUG && DEEP_DEBUG
            QNetManager.PrintLogMsc($"QNetObject of type {GetType().Name} initialized with identity {identity} and component index {ComponentIndex}.");
#endif

            Profiler.EndSample();
        }

        /// <summary>
        ///     OnInitialize is called on the QNetObject first spawn.
        ///     This method is a first called method from the init chain. 
        /// </summary>
        private JEMSmartMethodS _onInitialize;

        /// <summary>
        ///     Called when the object is being destroyed by the server.
        /// </summary>
        private JEMSmartMethodS _onNetworkDestroy;

        /// <summary>
        ///     Called on server to serialize current state of the object that next will be send to client.
        /// </summary>
        private JEMSmartMethodS<QNetMessageWriter> _onSerializeServerState;

        /// <summary>
        ///     Called on client to de-serialize current state of the object.
        /// </summary>
        private JEMSmartMethodS<QNetMessageReader> _onDeserializeServerState;

        /// <inheritdoc />
        protected override void LoadMethods()
        {
            // Invoke base method
            base.LoadMethods();

            Profiler.BeginSample("QNetObject.LoadMethods");

            _onInitialize = new JEMSmartMethodS(this, "OnInitialize");
            _onNetworkDestroy = new JEMSmartMethodS(this, "OnNetworkDestroy");

            _onSerializeServerState = new JEMSmartMethodS<QNetMessageWriter>(this, "OnSerializeServerState");
            _onDeserializeServerState = new JEMSmartMethodS<QNetMessageReader>(this, "OnDeserializeServerState");

            Profiler.EndSample();
        }

        /// <summary>
        ///     Fully destroy this Object.
        /// </summary>
        internal void DestroyObject()
        {
            // Update the isDestroying state.
            IsDestroying = true;

            _onNetworkDestroy.Invoke();
        }

        /// <summary>
        ///     Serialize and send state only of this exact QNetObject based component.
        /// </summary>
        /// <remarks>
        ///     Just a overload of <see cref="SerializeAndSendServerState"/> without target param.
        /// </remarks>
        public void SerializeAndSendServerStateToAll() => SerializeAndSendServerState(new QNetConnection());

        /// <summary>
        ///     Serialize and send state only of this exact QNetObject based component.
        /// </summary>
        /// <param name="target">If set, server state will be send only to given connection.</param>
        public void SerializeAndSendServerState(QNetConnection target)
        {
            if (!IsServer)
                throw new NotSupportedException("You can't serialize server object state while server is not active.");

            // Generate the outgoing message.
            var outgoingMessage = QNetManager.GenerateServerMessage(QNetUnityHeader.OBJECT_STATE);
            // Write the object identity.
            outgoingMessage.WriteUInt16(Identity);
            // Write the component index.
            outgoingMessage.WriteByte(ComponentIndex);
            // Serialize State.
            CallOnSerializeServerState(outgoingMessage);

            if (target.Equals(default(QNetConnection)))
            {
                // Send to all.
                QNetManager.SendToAll(QNetBaseChannel.DEFAULT, QNetMessageMethod.ReliableOrdered,
                    QNetUnityHeader.OBJECT_STATE, outgoingMessage);
            }
            else
            {
                // Send to target.
                QNetManager.Send(target, QNetBaseChannel.DEFAULT, QNetMessageMethod.ReliableOrdered,
                    QNetUnityHeader.OBJECT_STATE, outgoingMessage);
            }
        }

        /// <summary>
        ///     Initializes thi component like it has been added runtime via <see cref="GameObject.AddComponent()"/>
        /// </summary>
        /// <param name="typeIndex"/>
        /// <param name="componentIndex"/>
        /// <param name="full">If false, the onNetworkSpawn call will be ignored.</param>
        internal void InitializeCustomComponent(byte componentIndex, byte typeIndex, bool full)
        {
            // Set custom component active state.
            IsCustomComponent = true;

            // Update component index.
            ComponentIndex = componentIndex;

            // Register the custom component to list, so server can this new component for new clients.
            //if (Identity.WasPooled && Identity.CustomComponentsAdded.ContainsKey(ComponentIndex))
            //    Identity.CustomComponentsAdded[ComponentIndex] = typeIndex;
            //else
            //{
            //    Identity.CustomComponentsAdded.Add(ComponentIndex, typeIndex);
            //}

            if (Identity == null)
            {
                Debug.LogWarning("Identity component reference was missing when initializing custom component.", this);
                Identity = GetComponent<QNetIdentity>();
            }

            if (IsClient && Identity.CustomObjects.ContainsKey(ComponentIndex))
            {
                // As client, we may force override component type index.
                Identity.CustomObjects[ComponentIndex] = typeIndex;
            }
            else
            {
                Identity.CustomObjects.Add(ComponentIndex, typeIndex);
            }

            // Network spawn.
            if (!full) return;
            if (this is QNetBehaviour behaviour)
            {
                behaviour.CallOnNetworkSpawned();
            }
        }

        /// <summary>
        ///     Triggers default routine for destroying custom component.
        /// </summary>
        internal void DestroyCustomComponent(bool full)
        {
            // Call object destroy.
            DestroyObject();

            // Remove custom component from list.
            // Identity.CustomComponentsAdded.Remove(ComponentIndex);

            Identity.CustomObjects.Remove(ComponentIndex);
            Identity.Objects.Remove(this);
           
            // TODO: Update the ComponentIndex of the rest of the components in QNetIdentity
            //   so the index for next component added will be not the same as the old one.

            if (full)
            {
                Destroy(this);
            }
        }

        internal void CallOnSerializeServerState(QNetMessageWriter writer) => _onSerializeServerState.Invoke(writer);
        internal void CallOnDeserializeServerState(QNetMessageReader reader)
        {
            _onDeserializeServerState.Invoke(reader);
            HasStateDeserialized = true;
        }

        /// <summary>
        ///     Collects all Types that are subclass of <see cref="QNetObject"/>
        ///     and registers them in a array with byte index for faster and proper type serialization.
        /// </summary>
        /// <remarks>
        ///     Utilized by runtime component add/remove support.
        /// </remarks>
        public static void CollectAllQNetObjectTypes()
        {
            QNetObjectTypes.Clear();

            var baseType = typeof(QNetObject);
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();
            for (var index1 = 0; index1 < assemblies.Length; index1++)
            {
                var assembly = assemblies[index1];
                var allTypes = assembly.GetTypes();
                for (var index2 = 0; index2 < allTypes.Length; index2++)
                {
                    var type = allTypes[index2];
                    if (!type.IsClass)
                    {
                        continue;
                    }

                    if (!type.IsSubclassOf(baseType)) continue;
                    if (!GetQNetObjectIndex(type, out _))
                    {
                        QNetObjectTypes.Add((byte) QNetObjectTypes.Count, type);
                    }
                }
            }

#if DEBUG && DEEP_DEBUG
            var sb = new StringBuilder($"All QNetObject based types collected ({QNetObjectTypes.Count}).\n");
            foreach (var t in QNetObjectTypes)
                sb.AppendLine($"\t{t.Value.FullName}: {t.Key}");

            QNetManager.PrintLogMsc(sb.ToString());
#endif
        }

        /// <summary>
        ///     Gets the QNetObject type index by (full)type name.
        /// </summary>
        /// <remarks>
        ///     Utilized by runtime component add/remove support.
        /// </remarks>
        /// <exception cref="ArgumentNullException"/>
        public static bool GetQNetObjectIndex([NotNull] Type type, out byte index)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
            index = 255;
            foreach (var m in QNetObjectTypes)
            {
                if (m.Value != type) continue;
                index = m.Key;
                return true;
            }

            return false;
        }

        /// <summary>
        ///     Gets the QNetObject type by index.
        /// </summary>
        /// <remarks>
        ///     Utilized by runtime component add/remove support.
        /// </remarks>
        public static bool GetQNetObjectType(byte index, out Type type)
        {
            type = null;
            if (!QNetObjectTypes.ContainsKey(index)) return false;
            type = QNetObjectTypes[index];
            return true;

        }

        /// <summary>
        ///     Defines if the server is currently active.
        /// </summary>
        public static bool IsServer => QNetManager.Instance.IsServerActive;

        /// <summary>
        ///     Defines if the client is currently active.
        /// </summary>
        public static bool IsClient => QNetManager.Instance.IsClientActive;

        /// <summary>
        ///     Defines if any network peer is currently active.
        /// </summary>
        public static bool IsNetworkActive => QNetManager.Instance.IsNetworkActive;

        internal static bool ClientIsModifyingCustomComponent { get; set; }
        internal static Dictionary<byte, Type> QNetObjectTypes { get; } = new Dictionary<byte, Type>();

        public static implicit operator QNetConnection(QNetObject obj) => obj.Identity.OwnerConnection;
    }
}
