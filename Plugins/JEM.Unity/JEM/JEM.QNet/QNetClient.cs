//
// QNet Library Source
//
// Copyright (c) 2019 ADAM MAJCHEREK ALL RIGHTS RESERVED
//

using JEM.Core.Debugging;
using JEM.QNet.Extras;
using JEM.QNet.Messages;
using Lidgren.Network;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;

namespace JEM.QNet
{
    /// <inheritdoc />
    /// <summary>
    ///     QNet client.
    /// </summary>
    public partial class QNetClient : QNetPeer
    {
        /// <summary>
        ///     Defines whether this client is currently connected with server.
        /// </summary>
        public bool IsConnected { get; private set; }

        /// <summary>
        ///     Defines whether the client is currently connecting to server.
        /// </summary>
        public bool IsConnecting { get; private set; }

        /// <summary>
        ///     Original lidgren client instance.
        /// </summary>
        public NetClient OriginalClient { get; private set; }

        /// <summary>
        ///     QNetClient connection identity generated by QNetServer.
        /// </summary>
        public ushort ConnectionIdentity { get; private set; }

        /// <summary>
        ///     Original lidgren client connection to server.
        /// </summary>
        public NetConnection OriginalConnection { get; private set; }

        /// <summary>
        ///     Fixed reason of lasted disconnection from server.
        /// </summary>
        public string FixedLastDisconnectionReason { get; private set; }

        private bool _shutdownByException;
        private List<QNetMessageReader> IncomingMessages { get; } = new List<QNetMessageReader>();

        /// <inheritdoc />
        public QNetClient() : base("QNetClient")
        {
            // ignore
        }

        /// <inheritdoc />
        public override short GetSignatureSize() => QNetMessage.ResolveLocalHeaderSize();

        /// <inheritdoc />
        /// <exception cref="ArgumentNullException"/>
        /// <exception cref="ArgumentException"/>
        public override bool Start(QNetPeerConfiguration configuration)
        {
            if (IsStarted) throw new InvalidOperationException();
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (!IPAddress.TryParse(configuration.IpAddress, out var address))
                throw new ArgumentException($"'{configuration.IpAddress}' is not a valid address");

            // Setup Lidgren.Network configuration.
            var cfg = PrepareDefaultPeerConfig();
            cfg.MaximumConnections = configuration.MaxConnections;
            cfg.AcceptIncomingConnections = false;

            cfg.ConnectionTimeout = configuration.ConnectionTimeout;
            cfg.UseMessageRecycling = configuration.UseMessageRecycling;

            cfg.NetworkThreadName = "qnet_client";

            // Enable utilized messages.
            cfg.EnableMessageType(NetIncomingMessageType.ConnectionLatencyUpdated);

            // Create client instance.
            OriginalClient = new NetClient(cfg);

            // Run.
            IsStarted = true;
            Configuration = configuration;
            OriginalPeer = OriginalClient;
            OriginalClient.Start();

            // Create hail message.
            var hailMessage = OriginalClient.CreateMessage();
            hailMessage.Write(GetSignatureSize());

            // Try to connect with target.
            IsConnecting = true;
            OriginalConnection = OriginalClient.Connect(configuration.IpAddress, configuration.Port, hailMessage);

            JEMLogger.Log("QNetClient is trying to connect " +
                          $"with server at {configuration.IpAddress}:{configuration.Port}.", "QNet");
            QNetGlobal.ClientReference = this;
            return true;
        }

        /// <inheritdoc />
        public override void Stop(string stopReason)
        {
            if (!IsStarted)
            {
                return;
            }

            if (stopReason == null)
                stopReason = "null";

            JEMLogger.Log($"Stopping QNetClient. Reason: {stopReason}", "QNet");

            IsStarted = false;

            ConnectionIdentity = 0;
            OriginalClient?.Shutdown(stopReason);
            OriginalClient = null;
            OriginalPeer = null;
            OriginalConnection = null;
            Configuration = null;
            if (QNetGlobal.ClientReference == this) QNetGlobal.ClientReference = null;

            OnDisconnection?.Invoke(true, stopReason);
        }

        /// <inheritdoc />
        public override void RegisterLocalPeerHandlers()
        {
            // register local handler
            SetHandler(new QNetMessage(false, QNetBaseHeader.CONNECTION_SERVER_MESSAGE, OnConnectionServerMessage));
            SetHandler(new QNetMessage(false, QNetBaseHeader.DISCONNECTION_MESSAGE, OnDisconnectionMessage));
            SetHandler(new QNetMessage(false, QNetBaseHeader.CVAR_DATA, QNetCVarManager.OnCVarData));
            SetHandler(new QNetMessage(false, QNetBaseHeader.EXECUTOR_LOGS_DATA, QNetExecutor.OnExecutorLogsData));
        }

        private void OnConnectionServerMessage(QNetMessage message, QNetMessageReader reader, ref bool disallowRecycle)
        {
            // client has been accepted by server
            // apply it's identity and invoke event
            ConnectionIdentity = reader.ReadUInt16();

            var writer = GenerateOutgoingMessage(QNetBaseHeader.CONNECTION_CLIENT_MESSAGE);
            OnConnectionReady?.Invoke(reader, writer);
            Send((byte) QNetBaseChannel.DEFAULT, QNetMessageMethod.ReliableOrdered, writer);
        }

        private void OnDisconnectionMessage(QNetMessage message, QNetMessageReader reader, ref bool disallowRecycle)
        {
            FixedLastDisconnectionReason = reader.ReadString();
        }

        /// <inheritdoc />
        public override void PollMessages()
        {
            if (!IsStarted)
                return;

            NetIncomingMessage msg;
            while (OriginalClient != null && (msg = OriginalClient.ReadMessage()) != null)
            {
                switch (msg.MessageType)
                {
                    case NetIncomingMessageType.StatusChanged:
                        var status = (NetConnectionStatus) msg.ReadByte();
                        switch (status)
                        {
                            case NetConnectionStatus.InitiatedConnect:
                                // JEMLogger.Log("QNetClient connection initialized by target server.");
                                break;
                            case NetConnectionStatus.Connected:
                                if (IsConnecting)
                                {
                                    JEMLogger.Log("QNetClient successfully connected with" +
                                                  $" target server: {Configuration.IpAddress}:{Configuration.Port}", "QNet");

                                    IsConnecting = false;
                                    IsConnected = true;

                                    // do something with successfully connection and wait for server initial message
                                    Send(QNetBaseChannel.DEFAULT, QNetMessageMethod.ReliableOrdered, QNetBaseHeader.CONNECTION_MESSAGE);
                                    OnConnected?.Invoke();
                                }
                                else
                                {
                                    JEMLogger.LogWarning("Unexcepted connection event received :D", "QNet");
                                }

                                break;
                            case NetConnectionStatus.Disconnected:
                                var disconnectionReason = msg.ReadString();
                                if (IsConnecting)
                                {
                                    JEMLogger.LogError("Failed to connect with target server: " +
                                                       $"{Configuration.IpAddress}:{Configuration.Port}. " +
                                                       $"Reason: {disconnectionReason}", "QNet");

                                    IsConnecting = false;
                                    IsConnected = false;

                                    // do something with failed connection for ex. fail message
                                    OnDisconnection?.Invoke(false, disconnectionReason);
                                }
                                else
                                {
                                    JEMLogger.Log("Disconnected from server. " +
                                                  $"Reason: {disconnectionReason}", "QNet");

                                    IsConnected = false;

                                    // unload stuff that has been loaded by server and back to main menu
                                    OnDisconnection?.Invoke(true, disconnectionReason);
                                }

                                break;
                            default:
                                JEMLogger.Log("UnexceptedConnectionStatusChanged -> " +
                                              $"{status}", "QNet");
                                break;
                        }

                        break;
                    case NetIncomingMessageType.Data:
                        var message = ReadIncomingMessage(default(QNetConnection), msg);
                        OnMessagePoll?.Invoke(message);
                        IncomingMessages.Add(message);
                        break;
                    case NetIncomingMessageType.ConnectionLatencyUpdated:
                        ConnectionLatency = OriginalConnection.AverageRoundtripTime;
                        break;
                    case NetIncomingMessageType.ErrorMessage:
                        // Ignore this one, or write log only to file
                        break;
                    default:
                        if (Configuration == null || !Configuration.DrawNetworkWarningMessages)
                            break;

                        JEMLogger.LogWarning($"UnexceptedConnectionMessageReceived -> {msg.MessageType}", "QNet");
                        try
                        {
                            JEMLogger.LogWarning($"--> (String from unexcepted message: {msg.ReadString()})", "QNet");
                        }
                        catch (Exception)
                        {
                            JEMLogger.LogWarning("Unexcepted message does not have any string type data.", "QNet");
                        }

                        break;
                }
            }
        }

        /// <inheritdoc />
        public override void DispatchMessages()
        {
            for (var index = 0; index < IncomingMessages.Count; index++)
            {
                var message = IncomingMessages[index];
                if (_shutdownByException)
                {
                    continue;
                }

                var canRecycle = true;
                try
                {
                    var result = InvokeHandler(message);
                    if (!result.WasSuccessful)
                        Stop("ClientNotImplementedHandler");
                    else
                    {
                        if (result.DisallowToRecycle)
                            canRecycle = false;
                    }
                }
                catch (Exception ex)
                {
                    _shutdownByException = true;
                    JEMLogger.LogException("Client system encounter unhandled exception generated " +
                                           $"by data received from server. {ex.Message}", ex.StackTrace, "QNet");
                    Stop("UnhandledClientHeaderError");
                }

                // Recycle this message
                if (Configuration == null || Configuration.UseMessageRecycling && canRecycle)
                    OriginalClient?.Recycle(message.GetMessage());
            }

            IncomingMessages.Clear();
        }

        /// <summary>
        ///     Runs a <see cref="QNetServer"/> ping process.
        ///     The <see cref="QNetClientPingUpdate"/> delegate will be returned with need to be updated to receive the server info.
        /// </summary>
        /// <param name="serverAddress">Address of server to ping.</param>
        /// <param name="serverPort">Port of the server to ping.</param>
        /// <param name="result">A event that is called when Ping operation ends.</param>
        /// <returns>Returns a event that updates the process of ping client.</returns>
        public static QNetClientPingUpdate PingServer(string serverAddress, ushort serverPort, QNetClientPingResult result)
        {
            // Run stopwatch to measure RTT.
            var sw = Stopwatch.StartNew();
            var time = DateTime.Now;

            // Create ping client.
            var cfg = PrepareDefaultPeerConfig();
            cfg.UseMessageRecycling = false;

            // Create client instance.
            var pingClient = new NetClient(cfg);

            // Enable unconnected message data.
            pingClient.Configuration.SetMessageTypeEnabled(NetIncomingMessageType.UnconnectedData, true);
            pingClient.Start();

            // Create ping message.
            var pingMessage = pingClient.CreateMessage();
            pingMessage.Write((byte) 101);

            // Send the unconnected message.
            var pingTarget = new IPEndPoint(IPAddress.Parse(serverAddress), serverPort);
            pingClient.SendUnconnectedMessage(pingMessage, pingTarget);

            // Return the event and wait for respond.
            return delegate
            {
                // Check if there is a timeout.
                if ((DateTime.Now - time).Seconds >= 3)
                {
                    result?.Invoke(false, -1, null);
                    pingClient.Shutdown("PingClientShutdown");
                    return false;
                }

                // Read the messages for server respond.
                NetIncomingMessage msg;
                if ((msg = pingClient.ReadMessage()) != null)
                {
                    switch (msg.MessageType)
                    {
                        case NetIncomingMessageType.UnconnectedData:
                            sw.Stop();
                            result?.Invoke(true, (int) sw.ElapsedMilliseconds, msg);
                            pingClient.Shutdown("PingClientShutdown");
                            return false;
                    }

                    result?.Invoke(false, -1, null);
                    pingClient.Shutdown("PingClientShutdown");
                    return false;
                }

                return true;
            };
        }
    }
}