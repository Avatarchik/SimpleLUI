//
// QNet Library Source
//
// Copyright (c) 2019 ADAM MAJCHEREK ALL RIGHTS RESERVED
//

using JEM.Core.Extension;
using Lidgren.Network;
using System;
using System.Collections.Generic;

namespace JEM.QNet.Messages
{
    /// <summary>
    ///     QNet message reader.
    /// </summary>
    public sealed class QNetMessageReader
    {
        /// <summary>
        ///     Reference to the connection this reader has been generated by.
        /// </summary>
        public QNetConnection Connection { get; }

        /// <summary/>
        private NetIncomingMessage Message { get; }

        /// <summary/>
        public QNetMessageReader(QNetConnection connection, NetIncomingMessage message)
        {
            Connection = connection;
            Message = message;
        }

        /// <summary>
        ///     Reads a <see cref="int"/>.
        /// </summary>
        public int ReadInt32() => Message.ReadInt32();
        
        /// <summary>
        ///     Reads a unsigned <see cref="int"/>.
        /// </summary>
        public uint ReadUInt32() => Message.ReadUInt32();
        
        /// <summary>
        ///     Reads a <see cref="long"/>.
        /// </summary>
        public long ReadInt64() => Message.ReadInt64();
        
        /// <summary>
        ///     Reads a unsigned <see cref="long"/>.
        /// </summary>
        public ulong ReadUInt64() => Message.ReadUInt64();
        
        /// <summary>
        ///     Reads a <see cref="short"/>.
        /// </summary>
        public short ReadInt16() => Message.ReadInt16();
        
        /// <summary>
        ///     Reads a unsigned <see cref="short"/>.
        /// </summary>
        public ushort ReadUInt16() => Message.ReadUInt16();
        
        /// <summary>
        ///     Reads a <see cref="bool"/>.
        /// </summary>
        public bool ReadBool() => Message.ReadBoolean();
        
        /// <summary>
        ///     Reads a <see cref="float"/>.
        /// </summary>
        public float ReadSingle() => Message.ReadFloat();        

        /// <summary>
        ///     Reads a <see cref="double"/>.
        /// </summary>
        public double ReadDouble() => Message.ReadDouble();
        
        /// <summary>
        ///     Reads a <see cref="string"/>.
        /// </summary>
        public string ReadString() => Message.ReadString();

        /// <summary>
        ///     Reads a serialized message.
        ///     NOTE: Reading message without giving a <see cref="Type"/> is possible only when received data has been serialized with typeIndex.
        /// </summary>
        public IQNetSerializedMessage ReadMessage()
        {
            var isDefault = ReadBool();
            var typeIndex = Message.ReadByte();
            if (QNetPeer.GetSerializedMessageType(typeIndex, out var type))
            {
                return ReadMessage(type, isDefault);
            }

            throw new NullReferenceException($"Failed to find type of index {typeIndex}. " +
                                             $"Has QNetSerializedMessage been serialized with typeIndex?");
        }

        /// <summary>
        ///     Reads a message of <paramref name="type"/>.
        /// </summary>
        public IQNetSerializedMessage ReadMessage(Type type) => ReadMessage(type, ReadBool());
        
        /// <summary>
        ///     Reads a message of <paramref name="type"/>.
        /// </summary>
        public IQNetSerializedMessage ReadMessage(Type type, bool isDefault)
        {
            if (!typeof(IQNetSerializedMessage).IsAssignableFrom(type))
                throw new ArgumentException($"IQNetSerializedMessage is not assignable from type '{type.FullName}'.");
 
            if (isDefault)
            {
                if (type.IsValueType)
                    return Activator.CreateInstance(type) as IQNetSerializedMessage;

                return null;
            }

            if (Activator.CreateInstance(type) is IQNetSerializedMessage instance)
            {
                instance.DeSerialize(this);
                return instance;
            }

            throw new NotSupportedException("Failed to read serialized message. " +
                                            $"Target type is not valid type for IQNetSerializedMessage. (Type: '{type.FullName}')");
        }

        /// <summary>
        ///     Reads a message of <typeparamref name="TSerializedMessage"/> type.
        /// </summary>
        public TSerializedMessage ReadMessage<TSerializedMessage>() where TSerializedMessage : IQNetSerializedMessage
        {
            var isDefault = ReadBool();
            if (isDefault)
            {
                return default(TSerializedMessage);
            }

            var instance = FastObjectFactory<TSerializedMessage>.Instance();
            instance.DeSerialize(this);
            return instance;
        }

        /// <summary>
        ///     Reads a <see cref="byte"/>.
        /// </summary>
        public byte ReadByte() => Message.ReadByte();

        /// <summary>
        ///     Reads a signed <see cref="byte"/>.
        /// </summary>
        public sbyte ReadSByte() => Message.ReadSByte();

        /// <summary>
        ///     Reads a <see cref="byte"/> array.
        /// </summary>
        public byte[] ReadBytes()
        {
            var bytes = Message.ReadBytes(ReadUInt16());
            Message.ReadPadBits();
            return bytes;
        }

        /// <summary>
        ///     Read a <typeparamref name="TEnum"/>.
        /// </summary>
        /// <exception cref="ArgumentNullException"/>
        /// <exception cref="NotSupportedException"/>
        public TEnum ReadEnum<TEnum>() where TEnum : struct, IConvertible => (TEnum) ReadEnum(typeof(TEnum));
        
        /// <summary>
        ///     Read a <see cref="Enum"/>.
        /// </summary>
        /// <exception cref="ArgumentNullException"/>
        /// <exception cref="NotSupportedException"/>
        public object ReadEnum(Type enumType)
        {
            if (enumType == null) throw new ArgumentNullException(nameof(enumType));
            if (!enumType.IsEnum)
                throw new NotSupportedException($"Type {enumType} is not a enum.");

            var underlyingType = Enum.GetUnderlyingType(enumType);
            object value;
            if (underlyingType == typeof(byte))
                value = ReadByte();
            else if (underlyingType == typeof(short))
                value = ReadInt16();
            else if (underlyingType == typeof(ushort))
                value = ReadUInt16();
            else if (underlyingType == typeof(int))
                value = ReadInt32();
            else if (underlyingType == typeof(uint))
                value = ReadUInt32();
            else if (underlyingType == typeof(long))
                value = ReadInt64();
            else if (underlyingType == typeof(ulong))
                value = ReadUInt64();
            else throw new NotSupportedException($"TypeCode {underlyingType.Name} is not supported.");

            return Enum.Parse(enumType, value.ToString());
        }

        /// <summary>
        ///     Gets all the bytes reader have.
        /// </summary>
        public byte[] GetBytesRaw(int skip = 0)
        {
            var a = new byte[Message.LengthBytes - skip];
            Array.Copy(Message.PeekDataBuffer(), skip, a, 0, a.Length);
            return a;
        }

        /// <summary>
        ///     Reads a array of <typeparamref name="TType"/>.
        /// </summary>
        /// <exception cref="ArgumentNullException"/>
        public TType[] ReadArray<TType>(Func<TType> onDeserializeItem)
        {
            if (onDeserializeItem == null) throw new ArgumentNullException(nameof(onDeserializeItem));
            var isNull = ReadByte();
            if (isNull == 0)
                return null;

            var index = 0;
            var length = ReadUInt16();
            var array = new TType[length];
            while (index < array.Length)
            {
                array[index] = onDeserializeItem.Invoke();
                index++; 
            }

            return array;
        }

        /// <summary>
        ///     Reads a list of <typeparamref name="TType"/>.
        /// </summary>
        /// <exception cref="ArgumentNullException"/>
        public IList<TType> ReadList<TType>(Func<TType> onDeserializeItem)
        {
            if (onDeserializeItem == null) throw new ArgumentNullException(nameof(onDeserializeItem));
            var isNull = ReadByte();
            if (isNull == 0)
                return null;

            var index = 0;
            var length = ReadUInt16();
            var array = new TType[length];
            while (index < array.Length)
            {
                array[index] = onDeserializeItem.Invoke();
                index++;
            }

            return new List<TType>(array);
        }

        /// <summary>
        ///     A deserialization delegate of dictionary item.
        /// </summary>
        public delegate void DeserializeDictionaryItem<TKey, TValue>(out TKey key, out TValue value);

        /// <summary>
        ///     Reads a dictionary.
        /// </summary>
        public IDictionary<TKey, TValue> ReadDictionary<TKey, TValue>(DeserializeDictionaryItem<TKey, TValue> onDeserializeItem)
        {
            if (onDeserializeItem == null) throw new ArgumentNullException(nameof(onDeserializeItem));
            var isNull = ReadByte();
            if (isNull == 0)
                return null;

            var index = 0;
            var length = ReadUInt16();
            var dictionary = new Dictionary<TKey, TValue>();
            while (index < length)
            {
                onDeserializeItem.Invoke(out var key, out var value);
                dictionary.Add(key, value);

                index++;
            }

            return dictionary;
        }

        /// <summary>
        ///     Reads a <see cref="object"/>.
        ///     Reading a object is only possible when value has been written whit valueTypeIndex.
        /// </summary>
        public object ReadObject() => ReadObject(new object[] { });

        /// <summary>
        ///     Reads a <see cref="object"/>.
        ///     Reading a object is only possible when value has been written whit valueTypeIndex.
        /// </summary>
        public object ReadObject(params object[] additionalReaderParams) => QNetPeer.ReadObjectFromMessage(this, additionalReaderParams);

        /// <summary/>
        public void SkipPadBits() => Message.SkipPadBits();

        /// <summary>
        ///     Gets incoming message of this reader.
        /// </summary>
        public NetIncomingMessage GetMessage() => Message;    
    }
}